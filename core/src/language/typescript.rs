use crate::rust_types::{RustType, RustTypeFormatError, SpecialRustType, RustEnumShared};
use crate::{
    language::Language,
    rust_types::{RustEnum, RustEnumVariant, RustField, RustStruct, RustTypeAlias},
};
use std::{collections::HashMap, io::Write};

/// All information needed to generate Typescript type-code
#[derive(Default)]
pub struct TypeScript {
    /// Mappings from Rust type names to Typescript type names
    pub type_mappings: HashMap<String, String>,
}

impl Language for TypeScript {
    fn type_map(&self) -> &HashMap<String, String> {
        &self.type_mappings
    }

    fn format_special_type(
        &self,
        special_ty: &SpecialRustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        match special_ty {
            SpecialRustType::Vec(rtype) => {
                Ok(format!("{}[]", self.format_type(rtype, generic_types)?))
            }
            // We add optionality above the type formatting level
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_types),
            SpecialRustType::HashMap(rtype1, rtype2) => Ok(format!(
                "Record<{}, {}>",
                match rtype1.as_ref() {
                    RustType::Simple { id } if generic_types.contains(id) => {
                        return Err(RustTypeFormatError::GenericKeyForbiddenInTS(id.clone()));
                    }
                    _ => self.format_type(rtype1, generic_types)?,
                },
                self.format_type(rtype2, generic_types)?
            )),
            SpecialRustType::Unit => Ok("undefined".into()),
            SpecialRustType::String => Ok("string".into()),
            SpecialRustType::I8
            | SpecialRustType::U8
            | SpecialRustType::I16
            | SpecialRustType::U16
            | SpecialRustType::I32
            | SpecialRustType::U32
            | SpecialRustType::I54
            | SpecialRustType::U53
            | SpecialRustType::F32
            | SpecialRustType::F64 => Ok("number".into()),
            SpecialRustType::Bool => Ok("boolean".into()),
            SpecialRustType::U64
            | SpecialRustType::I64
            | SpecialRustType::ISize
            | SpecialRustType::USize => {
                panic!("64 bit types not allowed in Typeshare")
            }
        }
    }

    fn begin_file(&self, w: &mut dyn Write) -> std::io::Result<()> {
        writeln!(w, "/*")?;
        writeln!(w, " Generated by typeshare {}", env!("CARGO_PKG_VERSION"))?;
        writeln!(w, "*/")?;
        writeln!(w)?;
        Ok(())
    }

    fn write_type_alias(&self, w: &mut dyn Write, ty: &RustTypeAlias) -> std::io::Result<()> {
        self.write_comments(w, 0, &ty.comments)?;

        let r#type = self
            .format_type(&ty.r#type, ty.generic_types.as_slice())
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

        writeln!(
            w,
            "export type {}{}{} = {};\n",
            ty.id.renamed,
            (!ty.generic_types.is_empty())
                .then(|| format!("<{}>", ty.generic_types.join(", ")))
                .unwrap_or_default(),
            ty.r#type.is_optional().then(|| "?").unwrap_or_default(),
            r#type,
        )?;

        Ok(())
    }

    fn write_struct(&self, w: &mut dyn Write, rs: &RustStruct) -> std::io::Result<()> {
        self.write_comments(w, 0, &rs.comments)?;
        
        if rs.fields.iter().any(|field| field.flattened) {
            write!(w, "export type {}{} = ", 
                rs.id.renamed,
                (!rs.generic_types.is_empty())
                    .then(|| format!("<{}>", rs.generic_types.join(", ")))
                    .unwrap_or_default()
            )?;
            
            for (i, flattened) in rs.fields.iter().filter(|f| f.flattened).enumerate() {
                let ts_ty = self
                    .format_type(&flattened.ty, &rs.generic_types)
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                
                if i > 0 {
                    write!(w, " & {}", ts_ty)?;
                } else {
                    write!(w, "{}", ts_ty)?;
                }
            }
            
            if rs.fields.iter().any(|f| !f.flattened) {
                writeln!(w, " & {{")?;
                
                for inline in rs.fields.iter().filter(|f| !f.flattened) {
                    self.write_field(w, inline, &rs.generic_types)?;
                }
                
                writeln!(w, "}};\n")
            } else {
                writeln!(w, ";\n")
            }                
        } else {
            writeln!(
                w,
                "export interface {}{} {{",
                rs.id.renamed,
                (!rs.generic_types.is_empty())
                    .then(|| format!("<{}>", rs.generic_types.join(", ")))
                    .unwrap_or_default()
            )?;
            
            rs.fields
                .iter()
                .filter(|field| !field.flattened)
                .try_for_each(|f| self.write_field(w, f, rs.generic_types.as_slice()))?;
    
            writeln!(w, "}}\n")   
        }   
    }

    fn write_enum(&self, w: &mut dyn Write, e: &RustEnum) -> std::io::Result<()> {
        self.write_comments(w, 0, &e.shared().comments)?;

        let generic_parameters = (!e.shared().generic_types.is_empty())
            .then(|| format!("<{}>", e.shared().generic_types.join(", ")))
            .unwrap_or_default();

        match e {
            RustEnum::Unit(shared) => {
                write!(
                    w,
                    "export enum {}{} {{",
                    shared.id.renamed, generic_parameters
                )?;

                self.write_enum_variants(w, e, None)?;

                writeln!(w, "\n}}\n")
            }
            RustEnum::Adjacent { shared, tag_key, .. } | RustEnum::Algebraic { shared, tag_key, .. } => {
                write!(
                    w,
                    "export type {}{} = ",
                    shared.id.renamed, generic_parameters
                )?;
                
                let enum_tag_name = build_enum_tag_name(tag_key, shared);

                self.write_enum_variants(w, e, enum_tag_name.as_deref())?;

                write!(w, ";")?;
                writeln!(w)?;
                writeln!(w)?;
                
                if let Some(enum_type_name) = enum_tag_name {
                    write_enum_tag_type(w, &enum_type_name, shared)?;
                    writeln!(w)?;
                    writeln!(w)?;
                }
                
                Ok(())
            }
        }
    }
}

impl TypeScript {
    fn write_enum_variants(&self, w: &mut dyn Write, e: &RustEnum, enum_tag_ty: Option<&str>) -> std::io::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in
            // this case)
            RustEnum::Unit(shared) => shared.variants.iter().try_for_each(|v| match v {
                RustEnumVariant::Unit(shared) => {
                    writeln!(w)?;
                    self.write_comments(w, 1, &shared.comments)?;
                    write!(w, "\t{} = \"{}\",", shared.id.original, &shared.id.renamed)
                }
                _ => unreachable!(),
            }),

            // Write all the algebraic variants out (all three variant types are possible
            // here)
            RustEnum::Algebraic {
                tag_key,
                content_key,
                shared,
            } => shared.variants.iter().try_for_each(|v| {
                    writeln!(w)?;
                    self.write_comments(w, 1, &v.shared().comments)?;
                    let tag_value = enum_tag_ty.as_ref()
                        .map(|tag_ty| format!("{tag_ty}.{}", v.shared().id.original))
                        .unwrap_or_else(|| format!("\"{}\"", v.shared().id.renamed));
    
                    match v {
                        RustEnumVariant::Unit(_) => write!(
                            w,
                            "\t| {{ {}: {}, {}?: undefined }}",
                            tag_key, tag_value, content_key
                        ),
                        RustEnumVariant::Tuple { ty, .. } => {
                            let r#type = self
                                .format_type(ty, e.shared().generic_types.as_slice())
                                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                            write!(
                                w,
                                "\t| {{ {}: {}, {}{}: {} }}",
                                tag_key,
                                tag_value,
                                content_key,
                                ty.is_optional().then(|| "?").unwrap_or_default(),
                                r#type
                            )
                        }
                        RustEnumVariant::AnonymousStruct { fields, .. } => {
                            writeln!(
                                w,
                                "\t| {{ {}: {}, {}: {{",
                                tag_key, tag_value, content_key
                            )?;
    
                            fields.iter().try_for_each(|f| {
                                self.write_field(w, f, e.shared().generic_types.as_slice())
                            })?;
    
                            write!(w, "}}")?;
                            write!(w, "}}")
                        }
                    }
                }),
            RustEnum::Adjacent {
                tag_key,
                shared,
            } => shared.variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                let tag_value = enum_tag_ty.as_ref()
                    .map(|tag_ty| format!("{tag_ty}.{}", v.shared().id.original))
                    .unwrap_or_else(|| format!("\"{}\"", v.shared().id.renamed));

                match v {
                    RustEnumVariant::Unit(..) => write!(
                        w,
                        "\t| {{ {}: {} }}",
                        tag_key, tag_value,
                    ),
                    RustEnumVariant::Tuple { ty, .. } => {
                        let r#type = self
                            .format_type(ty, e.shared().generic_types.as_slice())
                            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                            
                        if ty.is_optional() { 
                            write!(
                                w,
                                "\t| ({{ {}: {} }} & Partial<{}>)",
                                tag_key,
                                tag_value,    
                                r#type,
                            )        
                        } else {
                            write!(
                                w,
                                "\t| ({{ {}: {} }} & {})",
                                tag_key,
                                tag_value,    
                                r#type,
                            )               
                        }
                    }
                    RustEnumVariant::AnonymousStruct { fields, .. } => {
                        writeln!(w, "\t| {{")?;
                        writeln!(w, " {}: {}, ", tag_key, tag_value)?;

                        fields.iter().try_for_each(|f| {
                            self.write_field(w, f, e.shared().generic_types.as_slice())
                        })?;

                        write!(w, "}}")
                    }
                }
            }),
        }
    }

    fn write_field(
        &self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> std::io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let ts_ty = self
            .format_type(&field.ty, generic_types)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
        let optional = field.ty.is_optional() || field.has_default;
        
        writeln!(
            w,
            "\t{}{}: {};",
            typescript_property_aware_rename(&field.id.renamed),
            optional.then(|| "?").unwrap_or_default(),
            ts_ty
        )?;        

        Ok(())
    }

    fn write_comments(
        &self,
        w: &mut dyn Write,
        indent: usize,
        comments: &[String],
    ) -> std::io::Result<()> {
        // Only attempt to write a comment if there are some, otherwise we're Ok()
        if !comments.is_empty() {
            let comment: String = {
                let tab_indent = "\t".repeat(indent);
                // If there's only one comment then keep it on the same line, otherwise we'll make a nice multi-line comment
                if comments.len() == 1 {
                    format!("{}/** {} */", tab_indent, comments.first().unwrap())
                } else {
                    let joined_comments = comments.join(&format!("\n{} * ", tab_indent));
                    format!(
                        "{tab}/**
{tab} * {comment}
{tab} */",
                        tab = tab_indent,
                        comment = joined_comments
                    )
                }
            };
            writeln!(w, "{}", comment)?;
        }
        Ok(())
    }
}

fn typescript_property_aware_rename(name: &str) -> String {
    if name.chars().any(|c| c == '-') {
        return format!("\"{}\"", name);
    }
    name.to_string()
}

fn build_enum_tag_name(tag_name: &str, shared: &RustEnumShared) -> Option<String> {
    let args = shared.decorators.get("enum_tag")?;
    
    match args.first() {
        Some(name) if !name.is_empty() => Some(name.clone()),
        _ => {
            let mut enum_type_name = shared.id.renamed.clone();
    
            let mut tag_chars = tag_name.chars();
            if let Some(c) = tag_chars.next() {
                enum_type_name.extend(c.to_uppercase());        
                enum_type_name.extend(tag_chars);
            } else {
                enum_type_name.push_str("Tag");
            }
            
            Some(enum_type_name)
        } 
    } 
}


fn write_enum_tag_type(
    w: &mut dyn Write,    
    enum_name: &str, 
    shared: &RustEnumShared
) -> std::io::Result<()> {
    writeln!(w, "export enum {} {{", enum_name)?;
    
    for variant in shared.variants.iter() {
        let variant_shared = variant.shared();
        
        writeln!(w, "\t{} = \"{}\",", variant_shared.id.original, variant_shared.id.renamed)?;
    }    
    writeln!(w, "}}\n")    
}